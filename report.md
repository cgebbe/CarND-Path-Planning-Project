# Report

The finished product can be separated into two modules, which are going to be described in more detail in the following

 - A path planner, which generates smooth paths that do not violate the speed, acceleration and jerk limits
 - A behavior planner, which decides what to do next, i.e. keep lane or change lane 

## Path planner - Generation of smooth paths

### Generating path in (x,y) coordinates
For the generation of smooth paths I followed the video tutorial by udacity (Project Q&A). It follows these steps:

1. Generate a few anchor points in Frenet-coordinates, which are spaced approximately 30m away from each other.
2. Convert those to x-y-coordinates
3. Append those anchor points to the points from the remaining path (given by the simulator)
4. Convert this combined path from the map coordinate system to the egovehicle coordinate system
5. Fit a spline to y(x) - in map coordinates
6. Sample points from y(x)-spline given a certain velocity (see next subsection for more details)
7. Convert those sampled points from egovehicle coordinate system back to map coordinate system

A new path was only generated, when there were less than ~8 points in the remaining path left. That means, that the generated path is always completely driven and there is no collision check or similar in between the path generations. Since this is a risk, the generated path is so short, that it can be driven in the next 0.5-1 second.

### Deciding speed in driving path, i.e. fix (x,y,t)-coordinates

An important decision is how wide apart the sampled points shall be. In this solution, the starting velocity is fixed by the remaining path points and the end velocity is given as a target. The velocity in between is newly defined for each sampled path points with the constraint that it can only deviate +/- 0.15 from the velocity chosen for the previously sampled point.

This solution is also very close to the presented udacity video tutorial.


## Behavior planner - Decision on when to change lanes

The behavior planner is implemented as a simple finite state machine (see state design pattern https://en.wikipedia.org/wiki/State_pattern) with three states:

 - Init(ialization) state
 - KeepLane state
 - ChangeLane state

Every time the behavior planner is called, it performs two actions:
 1. Determine the next best transition state and switching to it
 2. Let the new state plan the path

### Determining the next best state

For the Init state and the ChangeLane state, determining the next best state is implemented in a very simple manner: Both states shall plan the path exactly once and then transition to the KeepLane state.

For the KeepLane state, it is more complex: There are three possible transition states at every moment: KeepLane, ChangeLane to the left, ChangeLane to the right. Each of these possible transition states are evaluated by calculating a cost for them. These costs comprise:

 - feasiblity: Is this action possible? For example, when the egovehicle is already on the right lane, it cannot change more right
 - safety: Is this action safe? While keeping the lane is always considered safe, you have to make sure that you don't crash into another vehicle when changing lanes. Therefore, the distance to the nearest car as well as the time until collision is taken into account.
 - efficiency: Will the egovehicle be faster in another lane? This is measured by using the distance to the next car in front of the vehicle
 - degree of freedom: If two lanes have exactly the same costs, always choose the middle lane, because it offers a higher degree of freedom in the future.

The costs listed above are summed up in a hierarchical manner and the state with the lowest cost is chosen as the next state.

### Let new state plan path

All states plan the path as described above, i.e. by keeping the points from the remaining path, adding anchor points and setting a target velocity.

The KeepLane state sets two anchor points in the current lane. It sets the target velocity close to the velocity of the car in the front (if there is one). If the egovehicle is still far way from the nearest car in front, the target velocity will be slightly higher. In contrast, it will be slightly lower, if the distance is already below a certain threshold. The maximum target velocity is always set to 47.5mph.

The ChangeLane state sets two anchor points in the lane to change to, which are 60m away from the current egovehicle position. Otherwise, the lateral acceleration was too high in curves. Moreover, the target velocity is set to the current velocity of the car. Otherwise, the car might accelerate quicly while the car in the front performs a break which lead to a collision.

The initialization exists only for the following reason: As described above, smooth path are generated by taking into account the velocity of the last points of the remaining path. However, at the very beginning, there is no remaining path, so we have to fake one. Otherwise, it sets the path in the same way as the KeepLane state. I believe, that I could delete this state through slightly rewriting the smooth_path function.



# What I also tried

The above solution presents the final product, but there were many things I tried, which did not end up working. However, it might be interesting for others to read what has not worked and why.

## Path planner - Generation of smooth paths

### Generating path in (x,y) coordinates

I don't particularly like the current solution: It would result in invalid acceleration values if the car drives faster or if the curves are tighter. Thus, I tried two more general solutions:

- Given a few anchor points, you could fit a constrained B-Spline through them such that the derivatives of the B-Spline, which represent the velocity, acceleration and jerk, are within certain limits. However, I did not find a library to do that and writing one by myself would take a serious amount of time...
- Another approach I actually tried was to have anchor points as the goal for a motion controller. The motion controller would consider [yaw, dyaw, vel, dvel=acc, ddvel=jerk]. Yaw and Vel would be fed as a target (e.g. next waypoint 30m ahead). dyaw and ddvel would be set by the controller. I implemented a simple P-controller, which resulted the car to reach incredibly high yaw and acceleration values quickly. Looking back, I should have known much better. I guess I would need a twice integrative controller (I^2 ?) or a model predictive control to actual succeed with this approach. Since those types of control are not easy to implement, I dropped this approach.

### Deciding speed in driving path, i.e. fix (x,y,t)-coordinates

In the current approach, the velocity is allowed to change slightly between each sampled waypoint. In contrast to that, I also tried to fit a spline through the initial and target velocity and sample the velocity from that spline. While the resulting paths were even smoother than the current implementation, it became very difficult to avoid too high acceleration values when e.g. a car in front breaked.

# Future work

 - Currently, the egovehicle slightly deaccelerates when changing the lanes even though it should keep a constant velocity. I believe this is due to the fact that the velocity in curves is set slightly lower to prevent speeding up in curves. While it does not look smooth, the resulting trajecotry is within the permitted acceleration values, so I do not care that much about it.
 - Sometimes, the egovehicle drives itself in a deadlock. For example, the car can be in the right lane, with another car closely in front. The egovehicle cannot easily change lanes, because there is a car in the middle lane right left to the egovehicle. If the other car in the middle lane and the car in the front drive at exactly the same speed, the egovehicle will simply follow the car in the front, even if it drives super slowly. This situation could be resolved, if the egovehicle deaccelerates and then changes from the right to the left lane. However, such a maneuever is significantly  more complicated than the current simple logic would allow, thus I did not implement it.
